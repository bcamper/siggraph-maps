sources:
    osm:
        type: TopoJSON
        url:  //vector.mapzen.com/osm/all/{z}/{x}/{y}.topojson?api_key=vector-tiles-HqUVidw
        
camera:
    type: perspective
    vanishing_point: [0, -1000]

lights:
    light1:
        type: ambient
        direction: [1, 1, -.9]
        diffuse: .0
        ambient: 2.

styles:
    flatlines:
        base: lines
        lighting: false # ignore lights
    flatpolys:
        base: polygons
        lighting: false # ignore lights

    galaxy:
        base: polygons
        material:
            ambient:
                texture: galaxy.jpg
                mapping: spheremap
    stars:
        base: polygons
        material:
            ambient:
                texture: stars.jpg
                mapping: spheremap
                # scale: .0001
    buildings:
        base: polygons
        mix: galaxy
        animated: true
        shaders:
            defines:
                GRAIN_AMOUNT: .3
                NUM_OCTAVES: 1
            uniforms:
                u_frequency: 8.
            blocks:
                global: |
                    // 3d noise
                    float rand(vec2 co){
                        return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
                    }
                    vec3 mod289(vec3 x) {
                      return x - floor(x * (1.0 / 289.0)) * 289.0;
                    }

                    vec4 mod289(vec4 x)
                    {
                      return x - floor(x * (1.0 / 289.0)) * 289.0;
                    }

                    vec4 permute(vec4 x)
                    {
                      return mod289(((x*34.0)+1.0)*x);
                    }

                    vec4 taylorInvSqrt(vec4 r)
                    {
                      return 1.79284291400159 - 0.85373472095314 * r;
                    }

                    vec3 fade(vec3 t) {
                      return t*t*t*(t*(t*6.0-15.0)+10.0);
                    }

                    // Classic Perlin noise
                    float cnoise(vec3 P)
                    {
                      vec3 Pi0 = floor(P); // Integer part for indexing
                      vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
                      Pi0 = mod289(Pi0);
                      Pi1 = mod289(Pi1);
                      vec3 Pf0 = fract(P); // Fractional part for interpolation
                      vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
                      vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
                      vec4 iy = vec4(Pi0.yy, Pi1.yy);
                      vec4 iz0 = Pi0.zzzz;
                      vec4 iz1 = Pi1.zzzz;

                      vec4 ixy = permute(permute(ix) + iy);
                      vec4 ixy0 = permute(ixy + iz0);
                      vec4 ixy1 = permute(ixy + iz1);

                      vec4 gx0 = ixy0 * (1.0 / 7.0);
                      vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
                      gx0 = fract(gx0);
                      vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
                      vec4 sz0 = step(gz0, vec4(0.0));
                      gx0 -= sz0 * (step(0.0, gx0) - 0.5);
                      gy0 -= sz0 * (step(0.0, gy0) - 0.5);

                      vec4 gx1 = ixy1 * (1.0 / 7.0);
                      vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
                      gx1 = fract(gx1);
                      vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
                      vec4 sz1 = step(gz1, vec4(0.0));
                      gx1 -= sz1 * (step(0.0, gx1) - 0.5);
                      gy1 -= sz1 * (step(0.0, gy1) - 0.5);

                      vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
                      vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
                      vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
                      vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
                      vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
                      vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
                      vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
                      vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

                      vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
                      g000 *= norm0.x;
                      g010 *= norm0.y;
                      g100 *= norm0.z;
                      g110 *= norm0.w;
                      vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
                      g001 *= norm1.x;
                      g011 *= norm1.y;
                      g101 *= norm1.z;
                      g111 *= norm1.w;

                      float n000 = dot(g000, Pf0);
                      float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
                      float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
                      float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
                      float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
                      float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
                      float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
                      float n111 = dot(g111, Pf1);

                      vec3 fade_xyz = fade(Pf0);
                      vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
                      vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
                      float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
                      return 2.2 * n_xyz;
                    }
                color: |
                    float pixelSize = 4.;
                    float fps = .05;
                    float t = u_time * fps;
                    float t2 = u_time * fps +.66;
                    vec3 pos = floor(v_world_position.xyz/pixelSize);
                    vec3 sparkles = vec3(0.);
                    sparkles = vec3(cnoise(pos+t))*2.;
                    sparkles += vec3(cnoise(pos+t2))*2.;
                    // clamp
                    float minInput = .95;
                    float maxInput = 1.;
                    sparkles = min(max(sparkles - vec3(minInput), vec3(0.0)) / (vec3(maxInput) - vec3(minInput)), vec3(1.0));
                    // brighten 
                    sparkles += .5;
                    color.rgb *= sparkles;
                    
    roads:
        base: lines
        texcoords: true
        blend: add
        shaders:
            blocks:
                color: |
                    vec2 st = v_texcoord.xy;
                    color.rgb = vec3(st.xy*.5, 1.);
    
layers:
    earth:
        data: { source: osm, layer: earth }
        draw:
            stars:
                order: 0
                color: [.1, .1, .1]

    landuse:
        data: { source: osm, layer: landuse }
        parks:
            draw:
                stars:
                    order: 1
                    color: white
    water:
        data: { source: osm, layer: water }
        draw:
            stars:
                order: 3
                color: [0.671, 0.784, 0.949]

    roads:
        data: { source: osm, layer: roads }
        filter: { not: {kind: [rail] } }
        draw:
            roads:
                order: 7
                color: [0.65882, 0.65882, 0.50196]
                width: 10px
        highway:
            filter: { kind: highway }
            draw:
                flatlines:
                    color: [1.000, 0.863, 0.133]
                    width: 17px
                    outline:
                        width: 1
                        color: [0.671, 0.784, 0.949]


    # buildings are the only layer that gets lighting
    buildings:
        data: { source: osm }
        draw:
            buildings:
                order: 80
                # color: |
                #     function () {
                #         var a = feature.area;
                #         var h = feature.height;
                #         var v = Math.floor(Math.random(1)*2)*.25;
                #         var r = feature.area > 10000 ? .5 : 0.;
                #         var g = feature.height > 150 ? .5 : 0.;
                #         var b = feature.height > 150 ? .5 : 0.;                        
                #         return [v+r, v+g, v];
                #         // return [v, v, v];
                #     }
                extrude: function () { return feature.height || feature.area / 100 % 1 * 20 + 20; }
        